@model Article
@using System.Security.Claims

@{
    ViewData["Title"] = Model.Title;
    var currentUserId = User.Identity != null && User.Identity.IsAuthenticated
                        ? User.FindFirstValue(ClaimTypes.NameIdentifier)
                        : "";
}

<div class="container py-4">
    <!-- Title & Author -->
    <div class="mb-4">
        <h1 class="fw-bold">@Model.Title</h1>
        <p class="text-muted">
            By <strong>@Model.Author.Name</strong> on @Model.CreatedAt.ToString("dd MMM yyyy")
        </p>
    </div>

    <!-- Content -->
    <div class="mb-5">
        <p>@Model.Content</p>
    </div>

    <!-- Voting -->
    <div class="mb-4">
        <div class="d-flex align-items-center gap-3">
            <span class="h5 mb-0">Score: <span id="net-score">@ViewBag.NetScore</span></span>
            <button class="btn btn-sm btn-outline-success" id="btn-upvote" data-article-id="@Model.ArticleId">⬆️ Upvote</button>
            <button class="btn btn-sm btn-outline-danger" id="btn-downvote" data-article-id="@Model.ArticleId">⬇️ Downvote</button>
        </div>
    </div>

    <!-- Comments -->
    <div class="mb-4">
        <h4>Comments (<span id="comments-count">@ViewBag.CommentsCount</span>)</h4>

        <!-- Server-rendered list (also used as initial content) -->
        <ul class="list-group" id="comments-list">
            @foreach (var comment in Model.Comments.OrderByDescending(c => c.CreatedAt))
            {
                <li class="list-group-item" data-comment-id="@comment.CommentId" data-author-id="@comment.AuthorId">
                    <p class="comment-content">@comment.Content</p>
                    <small class="text-muted d-block">
                        By <strong>@comment.Author.Name</strong> 
                        @if (comment.UpdatedAt.HasValue)
                        {
                            <text>updated on @comment.UpdatedAt.Value.ToString("dd MMM yyyy HH:mm")</text>
                        }
                        else
                        {
                            <text>on @comment.CreatedAt.ToString("dd MMM yyyy HH:mm")</text>
                        }
                    </small>

                    @if (!string.IsNullOrEmpty(currentUserId) && comment.AuthorId == currentUserId)
                    {
                        <div class="mt-2 comment-controls">
                            <button type="button" class="btn btn-sm btn-outline-secondary btn-edit">Edit</button>
                            <button type="button" class="btn btn-sm btn-outline-danger btn-delete">Delete</button>
                        </div>
                    }
                </li>
            }
        </ul>
    </div>

    <!-- Add Comment -->
    @if (User.Identity != null && User.Identity.IsAuthenticated)
    {
        @Html.AntiForgeryToken()
        <form id="comment-form" class="mb-4">
            <input type="hidden" name="articleId" value="@Model.ArticleId" />
            <div class="mb-3">
                <textarea name="content" id="comment-content" class="form-control" rows="3" placeholder="Write your comment..." required></textarea>
            </div>
            <button type="submit" class="btn btn-primary">Add Comment</button>
        </form>
    }
    else
    {
        <p><a href="/Account/Login">Login</a> to add a comment.</p>
    }
</div>

@section Scripts {
    <script>
        // server-side current user id
        const currentUserId = '@currentUserId';

        // get antiforgery token (if present)
        function getAntiForgeryToken() {
            const tokenField = document.querySelector('input[name="__RequestVerificationToken"]');
            return tokenField ? tokenField.value : null;
        }

        async function vote(articleId, isUpvote) {
            await fetch(`/Votes/Vote?articleId=${articleId}&isUpvote=${isUpvote}`, { method: 'POST' });
            loadScore(articleId);
        }

        async function loadScore(articleId) {
            const res = await fetch(`/Votes/Count?articleId=${articleId}`);
            if (!res.ok) return;
            const data = await res.json();
            document.getElementById('net-score').innerText = data.netScore;
        }

        document.getElementById("btn-upvote")?.addEventListener("click", function () {
            const articleId = this.getAttribute("data-article-id");
            vote(articleId, true);
        });

        document.getElementById("btn-downvote")?.addEventListener("click", function () {
            const articleId = this.getAttribute("data-article-id");
            vote(articleId, false);
        });

        // Delete comment via AJAX
        async function deleteComment(commentId, liElement) {
            if (!confirm("Are you sure you want to delete this comment?")) return;
            const token = getAntiForgeryToken();
            const body = `commentId=${encodeURIComponent(commentId)}`;
            const headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
            if (token) headers['RequestVerificationToken'] = token;

            const res = await fetch('/Comments/Delete', {
                method: 'POST',
                headers,
                body
            });

            if (res.ok) {
                liElement.remove();
                const countEl = document.getElementById("comments-count");
                countEl.innerText = Math.max(0, parseInt(countEl.innerText || "0", 10) - 1);
            } else if (res.status === 403) {
                alert("You are not authorized to delete this comment.");
            } else {
                const json = await res.json().catch(()=>null);
                alert((json && json.message) ? json.message : "Failed to delete comment.");
            }
        }

        // Enter edit mode for a comment (inline)
        function enterEditMode(li) {
            if (li.querySelector('textarea')) return;

            const commentId = li.dataset.commentId;
            const contentP = li.querySelector('.comment-content');
            const originalText = contentP.textContent;

            contentP.style.display = 'none';

            const textarea = document.createElement('textarea');
            textarea.className = 'form-control mb-2';
            textarea.rows = 3;
            textarea.value = originalText;

            const saveBtn = document.createElement('button');
            saveBtn.type = 'button';
            saveBtn.className = 'btn btn-sm btn-primary me-2';
            saveBtn.textContent = 'Save';

            const cancelBtn = document.createElement('button');
            cancelBtn.type = 'button';
            cancelBtn.className = 'btn btn-sm btn-secondary';
            cancelBtn.textContent = 'Cancel';

            const editControls = document.createElement('div');
            editControls.className = 'mt-2';
            editControls.appendChild(saveBtn);
            editControls.appendChild(cancelBtn);

            const controlsContainer = li.querySelector('.comment-controls') || li;
            li.insertBefore(textarea, controlsContainer);

            if (controlsContainer.classList && controlsContainer.classList.contains('comment-controls')) {
                controlsContainer.style.display = 'none';
            }

            cancelBtn.addEventListener('click', () => {
                textarea.remove();
                editControls.remove();
                contentP.style.display = '';
                if (controlsContainer.classList && controlsContainer.classList.contains('comment-controls')) {
                    controlsContainer.style.display = '';
                }
            });

            saveBtn.addEventListener('click', async () => {
                const newContent = textarea.value.trim();
                if (!newContent) {
                    alert('Comment cannot be empty.');
                    return;
                }

                const token = getAntiForgeryToken();
                const body = `commentId=${encodeURIComponent(commentId)}&content=${encodeURIComponent(newContent)}`;
                const headers = { 'Content-Type': 'application/x-www-form-urlencoded' };
                if (token) headers['RequestVerificationToken'] = token;

                const res = await fetch('/Comments/Edit', {
                    method: 'POST',
                    headers,
                    body
                });

                if (res.ok) {
                    const json = await res.json();
                    
                    // Update comment content
                    contentP.textContent = json.content ?? newContent;
                    
                    // Update timestamp display
                    const timestampSmall = li.querySelector('small.text-muted');
                    if (timestampSmall) {
                        const timestampText = json.isUpdated 
                            ? `updated on ${json.updatedAt}`
                            : `on ${json.createdAt}`;
                        timestampSmall.innerHTML = `By <strong>${json.author}</strong> ${timestampText}`;
                    }
                    
                    textarea.remove();
                    editControls.remove();
                    contentP.style.display = '';
                    if (controlsContainer.classList && controlsContainer.classList.contains('comment-controls')) {
                        controlsContainer.style.display = '';
                    }
                } else if (res.status === 403) {
                    alert('You are not authorized to edit this comment.');
                } else {
                    const json = await res.json().catch(()=>null);
                    alert((json && json.message) ? json.message : 'Failed to edit comment.');
                }
            });

            li.insertBefore(editControls, controlsContainer.nextSibling);
        }

        // Delegated click handling for Edit/Delete buttons
        document.getElementById('comments-list').addEventListener('click', function (e) {
            const target = e.target;
            const li = target.closest('li');
            if (!li) return;

            if (target.classList.contains('btn-delete')) {
                const authorId = li.dataset.authorId;
                if (!currentUserId || String(authorId) !== String(currentUserId)) {
                    alert('You can only delete your own comments.');
                    return;
                }
                deleteComment(li.dataset.commentId, li);
            }

            if (target.classList.contains('btn-edit')) {
                const authorId = li.dataset.authorId;
                if (!currentUserId || String(authorId) !== String(currentUserId)) {
                    alert('You can only edit your own comments.');
                    return;
                }
                enterEditMode(li);
            }
        });

        // (Optional) loadComments function kept if you want to refresh later,
        // but do not call it automatically on page load unless the endpoint returns authorId.
        async function loadComments(articleId) {
            const res = await fetch(`/Comments/List?articleId=${articleId}`);
            if (!res.ok) {
                console.error('Failed to load comments');
                return;
            }
            const data = await res.json();
            const list = document.getElementById('comments-list');
            list.innerHTML = '';

            data.forEach(c => {
                const li = document.createElement('li');
                li.className = 'list-group-item';
                const id = c.id ?? c.commentId ?? c.CommentId;
                const authorId = c.authorId ?? (c.author && c.author.id) ?? c.AuthorId;
                const content = c.content ?? c.Content ?? '';
                const authorName = c.authorName ?? (c.author && c.author.name) ?? '';

                li.dataset.commentId = id;
                li.dataset.authorId = authorId;

                const p = document.createElement('p');
                p.className = 'comment-content';
                p.textContent = content;
                li.appendChild(p);

                const meta = document.createElement('small');
                meta.className = 'text-muted d-block';
                meta.textContent = `By ${authorName}`;
                li.appendChild(meta);

                if (currentUserId && String(authorId) === String(currentUserId)) {
                    const controls = document.createElement('div');
                    controls.className = 'mt-2 comment-controls';

                    const editBtn = document.createElement('button');
                    editBtn.type = 'button';
                    editBtn.className = 'btn btn-sm btn-outline-secondary btn-edit me-2';
                    editBtn.textContent = 'Edit';

                    const deleteBtn = document.createElement('button');
                    deleteBtn.type = 'button';
                    deleteBtn.className = 'btn btn-sm btn-outline-danger btn-delete';
                    deleteBtn.textContent = 'Delete';

                    controls.appendChild(editBtn);
                    controls.appendChild(deleteBtn);
                    li.appendChild(controls);
                }

                list.appendChild(li);
            });

            document.getElementById('comments-count').innerText = data.length;
        }

        // Function to add a new comment to the list dynamically
        function addCommentToList(commentData) {
            const list = document.getElementById('comments-list');
            if (!list) return;

            const li = document.createElement('li');
            li.className = 'list-group-item';
            li.setAttribute('data-comment-id', commentData.id);
            li.setAttribute('data-author-id', currentUserId);

            // Create comment content
            const contentP = document.createElement('p');
            contentP.className = 'comment-content';
            contentP.textContent = commentData.content;

            // Create timestamp info
            const timestampSmall = document.createElement('small');
            timestampSmall.className = 'text-muted d-block';
            
            const timestampText = commentData.isUpdated 
                ? `updated on ${commentData.updatedAt}`
                : `on ${commentData.createdAt}`;
            
            timestampSmall.innerHTML = `By <strong>${commentData.author}</strong> ${timestampText}`;

            li.appendChild(contentP);
            li.appendChild(timestampSmall);

            // Add edit/delete controls if user owns the comment
            if (currentUserId && currentUserId === commentData.authorId) {
                const controls = document.createElement('div');
                controls.className = 'mt-2 comment-controls';

                const editBtn = document.createElement('button');
                editBtn.type = 'button';
                editBtn.className = 'btn btn-sm btn-outline-secondary btn-edit me-2';
                editBtn.textContent = 'Edit';

                const deleteBtn = document.createElement('button');
                deleteBtn.type = 'button';
                deleteBtn.className = 'btn btn-sm btn-outline-danger btn-delete';
                deleteBtn.textContent = 'Delete';

                controls.appendChild(editBtn);
                controls.appendChild(deleteBtn);
                li.appendChild(controls);
            }

            // Add to the top of the list (newest first)
            list.insertBefore(li, list.firstChild);
        }

        // Add comment with AJAX
        document.getElementById("comment-form")?.addEventListener("submit", async function (e) {
            e.preventDefault();
            const articleId = this.querySelector("input[name=articleId]").value;
            const contentEl = document.getElementById("comment-content");
            const content = contentEl.value.trim();
            if (!content) return;

            const token = getAntiForgeryToken();
            const body = `articleId=${encodeURIComponent(articleId)}&content=${encodeURIComponent(content)}`;
            const headers = { "Content-Type": "application/x-www-form-urlencoded" };
            if (token) headers['RequestVerificationToken'] = token;

            const res = await fetch("/Comments/Add", {
                method: "POST",
                headers,
                body
            });

            if (res.ok) {
                const data = await res.json();
                contentEl.value = "";
                
                // Add the new comment to the page dynamically
                addCommentToList(data);
                
                // Update comment count
                const countEl = document.getElementById('comments-count');
                if (countEl) {
                    const currentCount = parseInt(countEl.innerText) || 0;
                    countEl.innerText = currentCount + 1;
                }
            } else {
                const json = await res.json().catch(()=>null);
                alert((json && json.message) ? json.message : "Failed to add comment.");
            }
        });

        // Initial setup: DO NOT reload comments here to avoid overwriting server-rendered markup.
        (function init() {
            const articleId = @Model.ArticleId;
            loadScore(articleId);
            // DO NOT call loadComments(articleId) here — it will replace the server-rendered list
            // which is the reason edit/delete buttons were disappearing.
        })();
    </script>
}
